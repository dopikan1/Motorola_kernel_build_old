name: Build Kernel (sukisusfs)

on:
  workflow_dispatch:

jobs:
  build-kernel:
    runs-on: ubuntu-22.04
    steps:
      - uses: actions/checkout@v4
      - name: Setup environment
        run: |
          echo "ANYKERNEL_SOURCE=$(cat config.env | grep -w "ANYKERNEL_SOURCE" | head -n 1 | cut -d "=" -f 2)" >> $GITHUB_ENV
          echo "ANYKERNEL_SOURCE_BRANCH=$(cat config.env | grep -w "ANYKERNEL_SOURCE_BRANCH" | head -n 1 | cut -d "=" -f 2)" >> $GITHUB_ENV
          echo "KERNEL_SOURCE=$(cat config.env | grep -w "KERNEL_SOURCE" | head -n 1 | cut -d "=" -f 2)" >> $GITHUB_ENV
          echo "KERNEL_SOURCE_BRANCH=$(cat config.env | grep -w "KERNEL_SOURCE_BRANCH" | head -n 1 | cut -d "=" -f 2)" >> $GITHUB_ENV
          echo "KERNEL_CONFIG=$(cat config.env | grep -w "KERNEL_CONFIG" | head -n 1 | cut -d "=" -f 2)" >> $GITHUB_ENV
          echo "BUILD_ARGS=$(cat config.env | grep -w "BUILD_ARGS" | head -n 1 | cut -d ":" -f 2)" >> $GITHUB_ENV
          sudo apt-get update
          sudo apt install python2 libncurses5
          sudo apt-get install libselinux-dev
          sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 1
          sudo update-alternatives --set python /usr/bin/python2
      - name: Pull toolchain
        run: |
          git clone --depth=1 https://github.com/LineageOS/android_prebuilts_gcc_linux-x86_aarch64_aarch64-linux-android-4.9 aarch64-linux-android-4.9
          git clone --depth=1 https://github.com/LineageOS/android_prebuilts_gcc_linux-x86_arm_arm-linux-androideabi-4.9 arm-linux-androideabi-4.9
          git clone https://github.com/xiangfeidexiaohuo/Snapdragon-LLVM.git clang
          
      - name: Pull kernel source
        run: |
          git clone --depth=1 ${{ env.KERNEL_SOURCE }} -b ${{ env.KERNEL_SOURCE_BRANCH }} kernel-source
          # Generate base defconfig from source tree


      - name: SukiSU integration (manual hook) and optional susfs prep
        run: |
          set -euxo pipefail
          cd kernel-source

          # 1) Prepare KernelSU/SukiSU in tree (do NOT select kprobe flow)
          #    We use the setup script only to stage KernelSU sources/Kconfig/Makefiles.
          #    Hooking is manual; we won't rely on kprobes.
          curl -LSs "https://raw.githubusercontent.com/SukiSU-Ultra/SukiSU-Ultra/main/kernel/setup.sh" \
            | bash -s susfs-main

          # 2) Optional: prepare susfs (experimental)
          #    If you have a known-good susfs patchset for your base, apply it here (recommended).
          #    Otherwise, keep this block but skip applying to avoid build surprises.
          #    Example (replace with your exact patch series/branch):
          # git clone --depth=1 https://gitlab.com/simonpunk/susfs4ksu susfs4ksu
          # git -C susfs4ksu log -1 --oneline || true
          # git am --3way --whitespace=fix susfs4ksu/patches/4.19/*.patch || (git am --abort; echo "susfs patch failed"; exit 1)

          # 3) Manually wire KernelSU hooks into core paths.
          #    We inject guarded calls under #ifdef CONFIG_KSU to keep diffs minimal and portable.

          inject_block() {
            local file="$1"; local anchor_regex="$2"; shift 2
            local tmp="$(mktemp)"
            if ! grep -Eq "$anchor_regex" "$file"; then
              echo "[FATAL] Anchor not found: $anchor_regex in $file"
              exit 1
            fi
            awk -v r="$anchor_regex" -v block="$*" '
              BEGIN{printed=0}
              {
                print $0
                if ($0 ~ r && !printed) {
                  print block
                  printed=1
                }
              }
              END{ if (printed==0) { exit 2 } }
            ' "$file" > "$tmp"
            mv "$tmp" "$file"
          }

          # 3a) fs/exec.c: do_execveat_common hook
          if grep -q "do_execveat_common" fs/exec.c; then
            inject_block fs/exec.c "do_execveat_common\\(" \
"#ifdef CONFIG_KSU
extern bool ksu_execveat_hook __read_mostly;
extern int ksu_handle_execveat(int *fd, struct filename **filename_ptr, void *argv, void *envp, int *flags);
extern int ksu_handle_execveat_sucompat(int *fd, struct filename **filename_ptr, void *argv, void *envp, int *flags);
#endif"
            inject_block fs/exec.c "return __do_execve_file\\(" \
"#ifdef CONFIG_KSU
  if (unlikely(ksu_execveat_hook))
    ksu_handle_execveat(&fd, &filename, &argv, &envp, &flags);
  else
    ksu_handle_execveat_sucompat(&fd, &filename, &argv, &envp, &flags);
#endif"
          else
            echo "[FATAL] fs/exec.c missing do_execveat_common"
            exit 1
          fi

          # 3b) fs/open.c: faccessat path
          if grep -q "long do_faccessat\\|SYSCALL_DEFINE3(faccessat" fs/open.c; then
            inject_block fs/open.c "long do_faccessat\\(|SYSCALL_DEFINE3\\(faccessat" \
"#ifdef CONFIG_KSU
extern int ksu_handle_faccessat(int *dfd, const char __user **filename_user, int *mode, int *flags);
#endif"
            inject_block fs/open.c "lookup_flags = .*" \
"#ifdef CONFIG_KSU
  ksu_handle_faccessat(&dfd, &filename, &mode, NULL);
#endif"
          else
            echo "[FATAL] fs/open.c missing faccessat path"
            exit 1
          fi

          # 3c) fs/read_write.c: vfs_read
          if grep -q "ssize_t vfs_read" fs/read_write.c; then
            inject_block fs/read_write.c "ssize_t vfs_read\\(" \
"#ifdef CONFIG_KSU
extern bool ksu_vfs_read_hook __read_mostly;
extern int ksu_handle_vfs_read(struct file **file_ptr, char __user **buf_ptr, size_t *count_ptr, loff_t **pos);
#endif"
            inject_block fs/read_write.c "ssize_t vfs_read\\([^)]*\\)\\s*\\{" \
"#ifdef CONFIG_KSU
  if (unlikely(ksu_vfs_read_hook))
    ksu_handle_vfs_read(&file, &buf, &count, &pos);
#endif"
          else
            echo "[FATAL] fs/read_write.c missing vfs_read"
            exit 1
          fi

          # 3d) fs/stat.c: vfs_statx or fallback to vfs_fstatat
          if grep -q "int vfs_statx\\(" fs/stat.c; then
            inject_block fs/stat.c "int vfs_statx\\(" \
"#ifdef CONFIG_KSU
extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
#endif"
            inject_block fs/stat.c "int vfs_statx\\([^)]*\\)\\s*\\{" \
"#ifdef CONFIG_KSU
  ksu_handle_stat(&dfd, &filename, &flags);
#endif"
          elif grep -q "int vfs_fstatat\\(" fs/stat.c; then
            inject_block fs/stat.c "int vfs_fstatat\\(" \
"#ifdef CONFIG_KSU
extern int ksu_handle_stat(int *dfd, const char __user **filename_user, int *flags);
#endif"
            inject_block fs/stat.c "int vfs_fstatat\\([^)]*\\)\\s*\\{" \
"#ifdef CONFIG_KSU
  ksu_handle_stat(&dfd, &filename, &flag);
#endif"
          else
            echo "[FATAL] fs/stat.c missing vfs_statx/vfs_fstatat"
            exit 1
          fi

          # 3e) Optional Safe Mode (recommended). If you enable this, also keep KPROBES disabled on manual hook.
          # if grep -q "static void input_handle_event" drivers/input/input.c; then
          #   inject_block drivers/input/input.c "static void input_handle_event\\(" \
          # "#ifdef CONFIG_KSU
          # extern bool ksu_input_hook __read_mostly;
          # extern int ksu_handle_input_handle_event(unsigned int *type, unsigned int *code, int *value);
          # #endif"
          #   inject_block drivers/input/input.c "int disposition = input_get_disposition\\(" \
          # "#ifdef CONFIG_KSU
          #   if (unlikely(ksu_input_hook))
          #     ksu_handle_input_handle_event(&type, &code, &value);
          # #endif"
          # fi

          cd ..
      - name: Build kernel (manual hook path)
        run: |
          set -euxo pipefail
          export KBUILD_BUILD_USER="hiahia"
          export PATH=$GITHUB_WORKSPACE/clang/bin:${PATH}
          args="                  ARCH=arm64 \
                                  O=../out \
                                  ${{ env.BUILD_ARGS }} \
                                  CLANG_TRIPLE=aarch64-linux-gnu- \
                                  CROSS_COMPILE=$GITHUB_WORKSPACE/aarch64-linux-android-4.9/bin/aarch64-linux-android- \
                                  CROSS_COMPILE_ARM32=$GITHUB_WORKSPACE/arm-linux-androideabi-4.9/bin/arm-linux-androideabi- "

          cd kernel-source

          # Generate base defconfig AFTER integration
          make ARCH=arm64 ${KERNEL_CONFIG}

          # KernelSU manual hook configs
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --enable CONFIG_KSU \
            --enable CONFIG_KSU_MANUAL_HOOK

          # Disable kprobes to avoid accidental safe-mode triggers on manual hook
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --disable CONFIG_KPROBES \
            --disable CONFIG_KPROBE_EVENTS || true

          # Tracepoint hook (alternative to manual). Leave disabled unless you switch methods.
          # ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
          #   --enable CONFIG_KSU_TRACEPOINT_HOOK

          # zram + zstd
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --enable CONFIG_ZRAM \
            --enable CONFIG_ZRAM_WRITEBACK \
            --enable CONFIG_CRYPTO_ZSTD \
            --enable CONFIG_ZSTD_COMPRESS \
            --enable CONFIG_ZSTD_DECOMPRESS
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --set-str CONFIG_ZRAM_DEFAULT_COMP "zstd" || true
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --enable CONFIG_ZRAM_DEF_COMP_ZSTD || true
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --enable CONFIG_ZRAM_MEMORY_TRACKING

          # KPM + kallsyms
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --enable CONFIG_KPM \
            --enable CONFIG_KALLSYMS \
            --enable CONFIG_KALLSYMS_ALL

          # IO scheduler Kyber default, CFQ fallback
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --disable CONFIG_DEFAULT_CFQ \
            --set-str CONFIG_DEFAULT_IOSCHED "kyber" \
            --enable CONFIG_MQ_IOSCHED_KYBER
          ./scripts/config --file arch/arm64/configs/${KERNEL_CONFIG} \
            --enable CONFIG_IOSCHED_CFQ \
            --enable CONFIG_CFQ_GROUP_IOSCHED

          # Optional: namespace umount backport needed for "Umount modules" feature on pre-5.9
          # (skip if you don't use that feature; otherwise backport path_umount and keep this note)

          # Confirm toggles present in defconfig
          grep -E 'CONFIG_KSU|CONFIG_KPM|CONFIG_KALLSYMS|CONFIG_KPROBES' arch/arm64/configs/${KERNEL_CONFIG} || true

          # Re-generate .config from the modified defconfig (no mrproper wipe)
          make ${args} ${KERNEL_CONFIG}

          # Quick sanity: ensure our hook sites compiled paths exist
          for sym in ksu_handle_execveat ksu_handle_execveat_sucompat ksu_handle_faccessat ksu_handle_vfs_read ksu_handle_stat; do
            grep -R "$sym" . || { echo "[FATAL] Missing symbol: $sym"; exit 1; }
          done

          clang -v
          make mrproper

          make -j$(nproc --all) ${args}

      - name: Package kernel
        run: |
          git clone --depth=1 ${{ env.ANYKERNEL_SOURCE }} -b ${{ env.ANYKERNEL_SOURCE_BRANCH }} AnyKernel3 && rm -rf AnyKernel3/.git AnyKernel3/.github AnyKernel3/LICENSE AnyKernel3/README.md
          if [[ -f out/arch/arm64/boot/Image.gz-dtb ]]; then
            cp out/arch/arm64/boot/Image.gz-dtb AnyKernel3/Image.gz-dtb
          elif [[ -f out/arch/arm64/boot/Image-dtb ]]; then
            cp out/arch/arm64/boot/Image-dtb AnyKernel3/Image-dtb
          elif [[ -f out/arch/arm64/boot/Image.gz ]]; then
            cp out/arch/arm64/boot/Image.gz AnyKernel3/Image.gz
          elif [[ -f out/arch/arm64/boot/Image ]]; then
            cp out/arch/arm64/boot/Image AnyKernel3/Image
          fi
          if [ -f out/arch/arm64/boot/dtbo.img ]; then
            cp out/arch/arm64/boot/dtbo.img AnyKernel3/dtbo.img
          fi

      - name: Upload kernel to artifact
        uses: actions/upload-artifact@v4
        with:
          name: AnyKernel3_kernel
          path: AnyKernel3/*
